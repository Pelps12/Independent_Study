//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.4
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Memory ()
//
module Memory // "mem"
(
    input logic clk,
    input logic mem_read,
    input logic mem_write,
    input logic rst,
    input logic [31:0] addr,
    input logic [31:0] write_data,
    output logic correct_instruction_flag,
    output logic [31:0] mem_data,
    input logic [15:0] axi_status_from,
    output logic [15:0] axi_status_to,
    output logic [8:0] axi_addr,
    output logic [31:0] axi_wdata,
    input logic [31:0] axi_rdata
);

    // Variables generated for SystemC signals
    logic [31:0] mapped_address;
    logic ram_en;
    logic rom_en;
    logic axi_from_en, axi_rdata_en;
    logic [31:0] ram_data;
    logic [31:0] rom_data;



    //------------------------------------------------------------------------------
    // Method process: select_data (memory.cpp:97:5) 

    always_latch 
    begin : select_data     // memory.cpp:97:5
        if (mem_read)
        begin
            if (ram_en)
            begin
                mem_data = ram_data;
            end
            if (rom_en)
            begin
                mem_data = rom_data;
            end
            if(axi_from_en)
            begin
                mem_data = axi_status_from;
            end
            if (axi_rdata_en) begin
                mem_data = axi_rdata;
            end
        end
    end

    //------------------------------------------------------------------------------
    // Method process: select_addr (memory.cpp:71:5) 

    always_comb 
    begin : select_addr     // memory.cpp:71:5
        logic is_rom_new;
        is_rom_new = addr[9];
        ram_en = 0;
        rom_en = 0;
        axi_from_en = 0;
        axi_rdata_en = 0;
        if (is_rom_new) begin
            if (addr[6]) begin
                if(addr[0]) begin
                    axi_rdata_en = 1;
                end
                else begin
                    axi_from_en = 1;
                end
            end
            else begin
                mapped_address = 32'(addr[8 : 0]);
                rom_en = 1;
            end

        end else begin
            mapped_address = addr;
            ram_en = 1;
        end
        
    end


    //------------------------------------------------------------------------------
    // Child module instances

    RAM ram (
        .clk(clk),
        .mem_write(mem_write),
        .rst(rst),
        .enable(ram_en),
        .addr(mapped_address),
        .write_data(write_data),
        .mem_data(ram_data),
        .axi_status_to(axi_status_to),
        .axi_addr(axi_addr),
        .axi_wdata(axi_wdata),
        .correct_instruction_flag(correct_instruction_flag)
    );

    ROM rom (
        .clk(clk),
        .mem_read(mem_read),
        .enable(rom_en),
        .rst(rst),
        .addr(mapped_address),
        .mem_data(rom_data)
    );

endmodule



//==============================================================================
//
// Module: RAM (memory.cpp:32:5)
//
module RAM // "mem.RAM"
(
    input logic clk,
    input logic mem_write,
    input logic rst,
    input logic enable,
    input logic [31:0] addr,
    input logic [31:0] write_data,
    output logic [31:0] mem_data,
    output logic correct_instruction_flag,
    output logic [15:0] axi_status_to,
    output logic [8:0] axi_addr,
    output logic [31:0] axi_wdata
);

// Variables generated for SystemC signals
(* ram_style = "block" *) logic [31:0] memory[512];

assign axi_status_to = memory['h22][15:0];
assign axi_addr = memory['h23][8:0];
assign axi_wdata = memory['h24];

//------------------------------------------------------------------------------
// Clocked THREAD: main_func (ram.cpp:34:5) 

// Thread-local variables
logic [31:0] mem_data_next;

initial begin
    `ifndef SYNTHESIS
        for (int i = 0; i < 512 ; i++) begin
            memory[i] = 0;
        end
    `endif
    `ifdef SYNTHESIS
        $readmemh("C:/Users/oluwa/Desktop/Coding/Hardware/new_computer/designs/memory.mem", memory);
    `else
        $readmemh("memory.mem", memory);
    `endif
    
end

// Next-state combinational logic
always_comb begin : main_func_comb     // ram.cpp:34:5
    main_func_func;
end
function void main_func_func;
    mem_data_next = mem_data;
    if (enable == 1)
    begin
        mem_data_next = memory[32'(addr)];
       
    end
endfunction

// Synchronous register update
always_ff @(negedge clk) 
begin : main_func_ff
    if ( rst ) begin
        correct_instruction_flag <= 0;
    end
    else begin
        mem_data <= mem_data_next;
        if (enable) begin
            //$display("Reading %x at addr: %x", mem_data_next, addr);
        end
        if(mem_write ==1 && enable == 1)
        begin
            memory[32'(addr)] = write_data;
            `ifndef SYNTHESIS
                $display("Writing at Addr: %d, Value: %x", addr, write_data);
            `endif
            if (addr == 32'd33 && write_data == 32'haaaa) begin
                correct_instruction_flag <= ~correct_instruction_flag;
            end
        end
    end
end

endmodule



//==============================================================================
//
// Module: ROM (memory.cpp:33:5)
//
module ROM // "mem.ROM"
(
    input logic clk,
    input logic mem_read,
    input logic enable,
    input logic rst,
    input logic [31:0] addr,
    output logic [31:0] mem_data
);

// Variables generated for SystemC signals
(* ram_style = "block" *) logic [31:0] memory[512];

//------------------------------------------------------------------------------
// Clocked THREAD: main_func (rom.cpp:30:5) 

// Thread-local variables
logic [31:0] mem_data_next;

initial begin
    `ifdef SYNTHESIS
        $readmemh("C:/Users/oluwa/Desktop/Coding/Hardware/new_computer/designs/firmware.mem", memory);
    `else
        $readmemh("firmware.mem", memory);
    `endif
    
end

// Next-state combinational logic
always_comb begin : main_func_comb     // rom.cpp:30:5
    main_func_func;
end
function void main_func_func;
    mem_data_next = mem_data;
    if (mem_read == 1 && enable == 1)
    begin
        mem_data_next = memory[32'(addr)];
    end
endfunction

// Synchronous register update
always_ff @(negedge clk) 
begin : main_func_ff
    if ( rst ) begin
    end
    else begin
        mem_data <= mem_data_next;
    end
end

endmodule

